use std::io::Write;

use convert_case::{Case, Casing as _};
use typeshare_model::Language;
use typeshare_model::prelude::*;

use crate::config::HeaderComment;
use crate::config::JavaConfig;
use crate::error::FormatSpecialTypeError;
use crate::util::indented_writer::IndentedWriter;

#[derive(Debug)]
pub struct Java {
    config: JavaConfig,
}

impl Language<'_> for Java {
    type Config = JavaConfig;

    const NAME: &'static str = "java";

    fn new_from_config(config: Self::Config) -> anyhow::Result<Self> {
        Ok(Self { config })
    }

    fn output_filename_for_crate(&self, crate_name: &CrateName) -> String {
        crate_name.as_str().to_case(Case::Pascal) + ".java"
    }

    fn format_special_type(
        &self,
        special_ty: &SpecialRustType,
        generic_context: &[TypeName],
    ) -> anyhow::Result<String> {
        Ok(match special_ty {
            SpecialRustType::Vec(rtype) => {
                format!(
                    "java.util.ArrayList<{}>",
                    self.format_type(rtype, generic_context)?
                )
            }
            SpecialRustType::Array(rtype, _) => {
                format!("{}[]", self.format_type(rtype, generic_context)?)
            }
            SpecialRustType::Slice(rtype) => {
                format!("{}[]", self.format_type(rtype, generic_context)?)
            }
            SpecialRustType::HashMap(rtype1, rtype2) => {
                format!(
                    "java.util.HashMap<{}, {}>",
                    self.format_type(rtype1, generic_context)?,
                    self.format_type(rtype2, generic_context)?
                )
            }
            SpecialRustType::Option(rtype) => self.format_type(rtype, generic_context)?,
            SpecialRustType::Unit => "Void".into(),
            // https://docs.oracle.com/javase/specs/jls/se23/html/jls-4.html#jls-IntegralType
            // Char in Java is 16 bits long, so we need to use String
            SpecialRustType::String | SpecialRustType::Char => "String".into(),
            SpecialRustType::I8 => "byte".into(),
            SpecialRustType::I16 => "short".into(),
            SpecialRustType::ISize | SpecialRustType::I32 => "int".into(),
            SpecialRustType::I54 | SpecialRustType::I64 => "long".into(),
            // byte in Java is signed, so we need to use short to represent all possible values
            SpecialRustType::U8 => "short".into(),
            // short in Java is signed, so we need to use int to represent all possible values
            SpecialRustType::U16 => "int".into(),
            // ing in Java is signed, so we need to use long to represent all possible values
            SpecialRustType::USize | SpecialRustType::U32 => "long".into(),
            // long in Java is signed, so we need to use BigInteger to represent all possible values
            SpecialRustType::U53 | SpecialRustType::U64 => "java.math.BigInteger".into(),
            // https://docs.oracle.com/javase/specs/jls/se23/html/jls-4.html#jls-PrimitiveType
            SpecialRustType::Bool => "boolean".into(),
            // https://docs.oracle.com/javase/specs/jls/se23/html/jls-4.html#jls-FloatingPointType
            SpecialRustType::F32 => "float".into(),
            SpecialRustType::F64 => "double".into(),
            _ => {
                return Err(
                    FormatSpecialTypeError::UnsupportedSpecialType(special_ty.clone()).into(),
                );
            }
        })
    }

    fn begin_file(&self, w: &mut impl Write, mode: FilesMode<&CrateName>) -> anyhow::Result<()> {
        match &self.config.header_comment {
            HeaderComment::None => {}
            HeaderComment::Default => {
                writeln!(w, "/**")?;
                writeln!(
                    w,
                    " * Generated by typeshare-java {}",
                    env!("CARGO_PKG_VERSION")
                )?;
                writeln!(w, " */")?;
                writeln!(w)?;
            }
            HeaderComment::Custom { comment } => {
                writeln!(w, "/**")?;
                for comment in comment.split("\n") {
                    writeln!(w, " * {comment}")?;
                }
                writeln!(w, " */")?;
                writeln!(w)?;
            }
        }

        if let Some(package) = &self.config.package {
            if let FilesMode::Multi(crate_name) = mode {
                writeln!(
                    w,
                    "package {}.{};",
                    package,
                    crate_name.as_str().to_case(Case::Pascal)
                )?;
            } else {
                writeln!(w, "package {package};")?;
            }
            writeln!(w)?;
        }

        match (self.config.namespace_class, mode) {
            (true, FilesMode::Multi(crate_name)) => {
                writeln!(
                    w,
                    "public class {} {{",
                    crate_name.as_str().to_case(Case::Pascal),
                )?;
                writeln!(w)?;
            }
            (true, FilesMode::Single) => {
                writeln!(w, "public class Namespace {{",)?;
                writeln!(w)?;
            }
            _ => {}
        }

        Ok(())
    }

    fn write_imports<'a, Crates, Types>(
        &self,
        writer: &mut impl Write,
        _crate_name: &CrateName,
        imports: Crates,
    ) -> anyhow::Result<()>
    where
        Crates: IntoIterator<Item = (&'a CrateName, Types)>,
        Types: IntoIterator<Item = &'a TypeName>,
    {
        for (path, ty) in imports {
            for t in ty {
                writeln!(
                    writer,
                    "import {}.{path}.{t};",
                    self.config
                        .package
                        .as_ref()
                        .map(|package| format!("{package}."))
                        .unwrap_or_default()
                )?;
            }
        }
        writeln!(writer).map_err(|err| err.into())
    }

    fn end_file(&self, w: &mut impl Write, _mode: FilesMode<&CrateName>) -> anyhow::Result<()> {
        if self.config.namespace_class {
            writeln!(w, "}}")?;
            writeln!(w)?;
        }

        Ok(())
    }

    fn write_type_alias(&self, _w: &mut impl Write, _t: &RustTypeAlias) -> anyhow::Result<()> {
        todo!("type aliases are not supported yet")
    }

    fn write_struct(&self, w: &mut impl Write, rs: &RustStruct) -> anyhow::Result<()> {
        let mut indented_writer =
            IndentedWriter::new(w, if self.config.namespace_class { 1 } else { 0 });

        self.write_comments(&mut indented_writer, 0, &rs.comments)?;

        write!(
            indented_writer,
            "public record {}{}{}(",
            self.config.prefix.as_ref().unwrap_or(&String::default()),
            rs.id.renamed,
            if !rs.generic_types.is_empty() {
                format!("<{}>", rs.generic_types.join(", "))
            } else {
                "".to_string()
            }
        )?;

        if let Some((last, elements)) = rs.fields.split_last() {
            writeln!(indented_writer)?;
            for f in elements.iter() {
                self.write_element(&mut indented_writer, f, rs.generic_types.as_slice())?;
                writeln!(indented_writer, ",")?;
            }
            self.write_element(&mut indented_writer, last, rs.generic_types.as_slice())?;
            writeln!(indented_writer)?;
        }

        writeln!(indented_writer, r") {{}}")?;
        writeln!(indented_writer)?;

        Ok(())
    }

    fn write_enum(&self, w: &mut impl Write, e: &RustEnum) -> anyhow::Result<()> {
        // TODO: Generate named types for any anonymous struct variants of this enum

        let mut indented_writer =
            IndentedWriter::new(w, if self.config.namespace_class { 1 } else { 0 });

        self.write_comments(&mut indented_writer, 0, &e.shared().comments)?;

        match e {
            RustEnum::Unit {
                shared,
                unit_variants,
            } => self.write_unit_enum(&mut indented_writer, shared, unit_variants),
            RustEnum::Algebraic { .. } => todo!("algebraic enums are not supported yet"),
        }
    }

    fn write_const(&self, _w: &mut impl Write, _c: &RustConst) -> anyhow::Result<()> {
        todo!("constants are not supported yet")
    }
}

impl Java {
    #[inline]
    fn is_java_letter(&self, c: char) -> bool {
        // https://docs.oracle.com/javase/specs/jls/se23/html/jls-3.html#jls-JavaLetter
        c.is_ascii_alphabetic() || c == '_' || c == '$'
    }

    #[inline]
    fn is_java_letter_or_number(&self, c: char) -> bool {
        // https://docs.oracle.com/javase/specs/jls/se23/html/jls-3.html#jls-JavaLetterOrDigit
        self.is_java_letter(c) || c.is_ascii_digit()
    }

    #[inline]
    fn is_java_reserved_keyword(&self, name: &str) -> bool {
        // https://docs.oracle.com/javase/specs/jls/se23/html/jls-3.html#jls-ReservedKeyword
        matches!(
            name,
            "abstract"
                | "continue"
                | "for"
                | "new"
                | "switch"
                | "assert"
                | "default"
                | "if"
                | "package"
                | "synchronized"
                | "boolean"
                | "do"
                | "goto"
                | "private"
                | "this"
                | "break"
                | "double"
                | "implements"
                | "protected"
                | "throw"
                | "byte"
                | "else"
                | "import"
                | "public"
                | "throws"
                | "case"
                | "enum"
                | "instanceof"
                | "return"
                | "transient"
                | "catch"
                | "extends"
                | "int"
                | "short"
                | "try"
                | "char"
                | "final"
                | "interface"
                | "static"
                | "void"
                | "class"
                | "finally"
                | "long"
                | "strictfp"
                | "volatile"
                | "const"
                | "float"
                | "native"
                | "super"
                | "while"
                | "_"
        )
    }

    #[inline]
    fn is_java_boolean_literal(&self, name: &str) -> bool {
        // https://docs.oracle.com/javase/specs/jls/se23/html/jls-3.html#jls-BooleanLiteral
        matches!(name, "true" | "false")
    }

    #[inline]
    fn is_java_null_literal(&self, name: &str) -> bool {
        // https://docs.oracle.com/javase/specs/jls/se23/html/jls-3.html#jls-NullLiteral
        matches!(name, "null")
    }

    fn santitize_itentifier(&self, name: &str) -> String {
        // https://docs.oracle.com/javase/specs/jls/se23/html/jls-3.html#jls-Identifier
        let mut chars = name.chars();

        // Ensure the first character is valid "JavaLetter"
        let first_char = chars
            .next()
            .map(|c| if self.is_java_letter(c) { c } else { '_' });

        // Ensure each remaining characters is a valid "JavaLetterOrDigit"
        let rest: String = chars
            .filter_map(|c| match c {
                '-' => Some('_'),
                c if self.is_java_letter_or_number(c) => Some(c),
                _ => None,
            })
            .collect();

        // Combine and return the sanitized identifier
        let name: String = first_char.into_iter().chain(rest.chars()).collect();

        if self.is_java_reserved_keyword(&name)
            || self.is_java_boolean_literal(&name)
            || self.is_java_null_literal(&name)
        {
            format!("_{name}")
        } else {
            name
        }
    }

    fn write_element(
        &self,
        w: &mut impl Write,
        f: &RustField,
        generic_types: &[TypeName],
    ) -> anyhow::Result<()> {
        self.write_comments(w, 1, &f.comments)?;
        let ty = self.format_type(&f.ty, generic_types)?;
        write!(
            w,
            "\t{} {}",
            ty,
            self.santitize_itentifier(f.id.renamed.as_str()),
        )
        .map_err(|err| err.into())
    }

    fn write_unit_enum(
        &self,
        w: &mut impl Write,
        shared: &RustEnumShared,
        unit_variants: &[RustEnumVariantShared],
    ) -> anyhow::Result<()> {
        writeln!(
            w,
            "public enum {}{} {{",
            self.config.prefix.as_ref().unwrap_or(&String::default()),
            &shared.id.renamed
        )?;

        if let Some((last_variant, variants)) = unit_variants.split_last() {
            for variant in variants {
                self.write_comments(w, 1, &variant.comments)?;
                writeln!(
                    w,
                    "\t{},",
                    self.santitize_itentifier(variant.id.renamed.as_str()),
                )?;
            }
            self.write_comments(w, 1, &last_variant.comments)?;
            writeln!(
                w,
                "\t{}",
                self.santitize_itentifier(last_variant.id.renamed.as_str()),
            )?;
        }

        writeln!(w, "}}")?;

        Ok(())
    }

    fn write_comment(
        &self,
        w: &mut impl Write,
        indent: usize,
        comment: &str,
    ) -> std::io::Result<()> {
        writeln!(w, "{}/// {}", "\t".repeat(indent), comment)?;
        Ok(())
    }

    fn write_comments(
        &self,
        w: &mut impl Write,
        indent: usize,
        comments: &[String],
    ) -> std::io::Result<()> {
        comments
            .iter()
            .try_for_each(|comment| self.write_comment(w, indent, comment))
    }
}
